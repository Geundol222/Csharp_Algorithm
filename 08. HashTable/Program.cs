namespace _08._HashTable
{
    internal class Program
    {
        /******************************************************
		 * 해시테이블 (HashTable) ******* 중요 *******
		 * 
		 * 키 값을 해시함수로 해싱하여 해시테이블의 특정 위치로 직접 엑세스하도록 만든 방식
		 * 특정 조건을 만족하면 지정된 인덱스에 바로 찾아가게 할 수 있기때문에 탐색, 삽입, 삭제에서 큰 이점이 있다.
		 * 데이터를 집어넣을때 데이터와 함께 키값을 같이 설정해 주어 해싱을 거쳐 배열에 저장하는 방식이다.
		 * 굉장히 많은 자리를 차지하기 때문에 공간을 포기하고 속도를 채택한 자료구조이다.
		 * 리스트는 숫자를 가지고 빠르게 접근하고 싶을 때, 딕셔너리는 키값을 가지고 빠르게 접근하고 싶을 때 사용한다.
		 * 따라서 키값은 숫자보다는 string같은 자료형을 활용한다.
		 * 목욕탕 키 : 키값
		 * 나의 물건 : 데이터
		 * 목욕탕 주인 : 해시함수
		 * 해싱 : 키 값으로 들어온 자료형을 특정 인덱스로 변환해 주는 작업
		 * 해시 : 임의의 길이를 가진 데이터를 고정된 길이를 가진 데이터로 매핑
		 ******************************************************/

        // <해시함수의 조건>
        // 입력에 대한 해시함수의 결과가 항상 동일한 값이어야 한다.(키값을 넣었을 때 보관된 인덱스와 키값으로 뺄때 빼오는 인덱스가 같아야함)

        // <해시함수의 효율>
        // 1. 해시함수 자체가 느린경우 의미가 없음 (처리속도가 빠를수록 효율이 좋음)
        // 2. 해시함수의 결과는 밀집도가 낮아야한다.
        // 3. 해시테이블의 크기가 클수록 효율이 좋다.

        // <해시테이블의 시간복잡도>
        // 접근			탐색		삽입		삭제
        //  X			O(1)		O(1)		O(1)

        // <해시테이블 주의점 - 충돌>
        // 해시함수가 서로 다른 입력 값에 대해 동일한 해시테이블 주소를 반환하는 것
        // 모든 입력 값에 대해 고유한 해시 값을 만드는 것은 불가능하며 충돌은 피할 수 없음
        // 대표적인 충돌 해결방안으로 체이닝과 개방주소법이 있음

        // <충돌해결방안 - 체이닝>
        // 해시 충돌이 발생하면 연결리스트로 데이터들을 연결하는 방식
        // 나중에 데이터를 찾을 경우 해당 위치에서 링크드리스트를 순회하면서 찾는 데이터를 반환해준다.
        // 링크드리스트를 사용한다는 것에서 노드기반이므로 C#에서는 체이닝을 사용하고 있지는 않음
        // 장점 : 해시테이블에 자료가 많아지더라도 성능저하가 적음
        // 단점 : 해시테이블 외 추가적인 저장공간이 필요

        // <충돌해결방안 - 개방주소법>
        // 해시 충돌이 발생하면 다른 빈 공간에 데이터를 삽입하는 방식 (해당 주소값의 그 다음 주소를 사용하게 됨)
        // 해시 충돌시 선형탐색, 제곱탐색, 이중해시 등을 통해 다른 빈 공간을 선정
        // 장점 : 추가적인 저장공간이 필요하지 않음, 삽입삭제시 오버헤드가 적음
        // 단점 : 해시테이블에 자료가 많아질수록 성능저하가 많음
        // 해시테이블의 공간 사용률이 높을 경우 성능저하가 발생하므로 재해싱 과정을 진행함
        // 재해싱 : 해시테이블의 크기를 늘리고 테이블 내의 모든 데이터를 다시 해싱 

        enum ItemType
        {
            Head,
            Armor,
        }

        static void Dictionary()
        {
            Dictionary<string, Item> dictionary = new Dictionary<string, Item>();
            // Dictionary<ItemType, Item> enumDictionary = new Dictionary<ItemType, Item>(); // 열거형도 가능

            // 추가
            dictionary.Add("초기아이템", new Item("초보자용 검", 10));
            dictionary.Add("초기방어구", new Item("초보자용 가죽갑옷", 30));
            dictionary.Add("전직아이템", new Item("푸른결정", 1));

            // dictionary.Add("초기아이템", new Item("초보자용 검", 10));     // 중복키값은 허용되지 않음
            dictionary["초기아이템"] = new Item("초보자용 나무망치", 20);

            // 탐색
            Console.WriteLine(dictionary["초기아이템"].name);

            // 접근
            dictionary.Remove("전직아이템");

            // 확인(탐색)
            if (dictionary.ContainsKey("초기아이템"))
            {
                Console.WriteLine("딕셔너리에 초기 아이템 있음");
            }
        }

        static void Main(string[] args)
        {
            Dictionary();
        }

        public class Item
        {
            public string name;
            public int weight;

            public Item(string name, int weight)
            {
                this.name = name;
                this.weight = weight;
            }
        }
    }
}